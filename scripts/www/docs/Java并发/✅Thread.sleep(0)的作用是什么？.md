# 典型回答


Thread的sleep会让线程暂时释放CPU资源，然后进入到TIMED_WAITING状态，等到指定时间之后会再尝试获取CPU时间片。



sleep方法需要指定一个时间，表示sleep的毫秒数，但是有的时候我们会见到Thread.sleep(0)



**这种用法其实就是让当前线程释放一下CPU时间片，然后重新开始争抢。**



这种用法一般比较少见，很多时候在一些底层框架中，可以用来做线程调度，比如某个线程长时间占用CPU资源，这时候通过sleep(0)让线程主动释放CPU时间片，让其他线程可以进行一次公平的争抢。



# 扩展知识


## 和yield的区别


`Thread.yield()`的主要作用是提示调度器，当前线程愿意让出 CPU，给其他同优先级或更高优先级的线程运行机会。但是它不保证当前线程一定会暂停，也不保证其他线程会立即运行。



Thread.sleep(0)其实也不保证一定能被其他线程获取到CPU时间片，但是他会先释放CPU，然后再参加竞争。这一点和yield有点区别。



**Thread.sleep(0)是可以被中断的**，如果被中断，会抛出异常InterruptedException，而Thread.yield()则无法被中断。



还有个小小差别，就是`yield()` 的实现是依赖于底层操作系统的线程调度策略。在某些系统上，它不保证一定能起作用（例如现代 Linux 的 CFS 调度器对 yield 支持有限<font style="color:rgb(17, 17, 51);">）。</font>

